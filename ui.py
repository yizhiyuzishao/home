# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
from pyexpat import model
from detectron2.engine import DefaultTrainer
from detectron2.checkpoint import DetectionCheckpointer

from detectron2.evaluation import COCOEvaluator, inference_on_dataset,testing
from detectron2.evaluation.evaluator import DatasetEvaluators
from detectron2.data import build_detection_test_loader
from detectron2.utils import comm
import matplotlib.pyplot as plt
import torch
from detectron2.utils.logger import setup_logger
setup_logger()
from detectron2.modeling import build_model
from detectron2.engine import DefaultPredictor
from detectron2.config import get_cfg
from detectron2.utils.visualizer import Visualizer
from detectron2.utils.visualizer import ColorMode
from detectron2.data import DatasetCatalog, MetadataCatalog
from detectron2.data.datasets.coco import load_coco_json
from Distill_GID_detectron2.GID.gid.config import add_distill_cfg
from detectron2.checkpoint.detection_checkpoint import DetectionCheckpointer
from detectron2.engine import DefaultTrainer, default_argument_parser, default_setup, hooks, launch
from PyQt5.QtGui import QPixmap
from PyQt5 import QtCore, QtGui, QtWidgets
import os
from PyQt5.QtWidgets import QWidget, QMessageBox, QApplication, QFileDialog
import cv2
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from detectron2.evaluation.evaluator import DatasetEvaluator
from torch.nn.parallel import DataParallel, DistributedDataParallel
from PyQt5 import QtCore, QtGui, QtWidgets
 #category: id --> {'dys': 1, 'hs': 2, 'lw': 3, 'my': 4, 'ps': 5, 'xxzw': 6, 'ys': 7, 'zw': 8}
 #category: id --> {'missing_hole': 1, 'mouse_bite': 2, 'open_circuit': 3, 'short': 4, 'spur': 5, 'spurious_copper': 6}

DATASET= '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/datasets/PCBdataset'
TRAIN= os.path.join(DATASET, 'images')
ANN = os.path.join(DATASET , 'Annotations')
TRAIN_J = os.path.join(ANN, 'train.json')
VAL = os.path.join(DATASET, 'images')
VAL_J= os.path.join(ANN, 'val.json')
PREDEFINED_SPLITS_DATASET = {"test": (VAL, VAL_J),"train": (TRAIN, TRAIN_J),}
DatasetCatalog.register("train", lambda: load_coco_json(TRAIN_J, TRAIN))
MetadataCatalog.get("train").set(json_file=TRAIN_J, image_root=TRAIN,evaluator_type="coco")
DatasetCatalog.register("val", lambda: load_coco_json(VAL_J, VAL))
MetadataCatalog.get("val").set(json_file=VAL_J, image_root=VAL,evaluator_type="coco")
DATASET_ROOT = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/datasets/coco'
ANN_ROOT = os.path.join(DATASET_ROOT , 'annontations')
TRAIN_JSON = os.path.join(ANN_ROOT, 'small-train.json')
TRAIN_PATH = os.path.join(DATASET_ROOT, 'images')
VAL_PATH = os.path.join(DATASET_ROOT, 'images')
VAL_JSON = os.path.join(ANN_ROOT, 'small-val.json')
PREDEFINED_SPLITS_DATASET = {"coco_test": (VAL_PATH, VAL_JSON),"coco_train": (TRAIN_PATH, TRAIN_JSON),}
DatasetCatalog.register("coco_train", lambda: load_coco_json(TRAIN_JSON, TRAIN_PATH))
MetadataCatalog.get("coco_train").set(json_file=TRAIN_JSON, image_root=TRAIN_PATH,evaluator_type="coco")
DatasetCatalog.register("coco_val", lambda: load_coco_json(VAL_JSON, VAL_PATH))
MetadataCatalog.get("coco_val").set(json_file=VAL_JSON, image_root=VAL_PATH,evaluator_type="coco") 

class DefaultTrainerDistill(DefaultTrainer):
    def __init__(self, cfg):
        """
        Args:
            cfg (CfgNode):
        """
        super().__init__(cfg)

        # checkpointers for Teacher & Student parameters init
        curr_model = self._trainer.model
        if isinstance(self._trainer.model, (DistributedDataParallel, DataParallel)):
            curr_model = curr_model.module
        self.checkpointer_te = DetectionCheckpointer(
            curr_model.teacher,
        )
        self.checkpointer_st = DetectionCheckpointer(
            curr_model.student,
        )


    def resume_or_load(self, resume=True):
        """
        If `resume==True` and `cfg.OUTPUT_DIR` contains the last checkpoint (defined by
        a `last_checkpoint` file), resume from the file. Resuming means loading all
        available states (eg. optimizer and scheduler) and update iteration counter
        from the checkpoint. ``cfg.MODEL.WEIGHTS`` will not be used.
        Otherwise, this is considered as an independent training. The method will load model
        weights from the file `cfg.MODEL.WEIGHTS` (but will not load other states) and start
        from iteration 0.
        Args:
            resume (bool): whether to do resume or not
        """
        if resume:
            self.checkpointer.resume_or_load(self.cfg.MODEL.WEIGHTS, resume=resume)
        else:
            self.checkpointer_te.resume_or_load(self.cfg.DISTILL.TEACHER_CFG.MODEL.WEIGHTS, resume=resume)
            self.checkpointer_st.resume_or_load(self.cfg.DISTILL.STUDENT_CFG.MODEL.WEIGHTS, resume=resume)
        if resume and self.checkpointer.has_checkpoint():
            # The checkpoint stores the training iteration that just finished, thus we start
            # at the next iteration
            self.start_iter = self.iter + 1

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1230, 700)
        # 禁止拉伸窗口大小
        MainWindow.setFixedSize(MainWindow.width(), MainWindow.height())
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.layoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.layoutWidget.setGeometry(QtCore.QRect(21, 11, 213, 300))
        self.layoutWidget.setObjectName("layoutWidget")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.layoutWidget)
        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_2.setObjectName("gridLayout_2")

        self.cmodel = QtWidgets.QLabel(self.layoutWidget)
        self.cmodel.setObjectName("cmodel")
        self.gridLayout_2.addWidget(self.cmodel, 0, 0, 1, 1)

        self.comboBox = QtWidgets.QComboBox(self.layoutWidget)
        self.comboBox.addItem("支持的五种模型缺陷检测的对比")
        self.comboBox.addItem("res18-fpn-retinanet")
        self.comboBox.addItem("res50-fpn-retinanet")
        self.comboBox.addItem("res101-fpn-retinanet")
        self.comboBox.addItem("res101-50-fpn-retinanet")
        self.comboBox.addItem("res101-18-fpn-retinanet")
        self.comboBox.setObjectName("comboBox")
        self.gridLayout_2.addWidget(self.comboBox, 1, 0, 1, 2)

        self.openpic = QtWidgets.QPushButton(self.layoutWidget) 
        self.gridLayout_2.addWidget(self.openpic, 2, 0, 1, 1)
        self.openpic.setObjectName("openpic")
        self.openpic.clicked.connect(self.open_file)
       
        self.openfloder = QtWidgets.QPushButton(self.layoutWidget)
        self.openfloder.clicked.connect(self.open_floder)
        self.openfloder.setObjectName("openfloder")
        self.gridLayout_2.addWidget(self.openfloder, 2, 1, 1, 1)
        self.flpath = QtWidgets.QLabel(self.centralwidget)
        self.flpath.setGeometry(QtCore.QRect(170, 100, 0, 0))
        self.flpath.setObjectName("flpath")

        self.openpkl = QtWidgets.QPushButton(self.layoutWidget)
        self.openpkl.clicked.connect(self.open_pth)
        self.openpkl.setObjectName("openpkl")
        self.gridLayout_2.addWidget(self.openpkl, 3, 0, 1, 1)
        self.pth = QtWidgets.QLabel(self.centralwidget)
        self.pth.setGeometry(QtCore.QRect(150, 30, 0, 0))
        self.pth.setObjectName("pth")

        self.openfl = QtWidgets.QPushButton(self.layoutWidget)
        self.openfl.clicked.connect(self.click_floder)
        self.openfl.setObjectName("openfl")
        self.gridLayout_2.addWidget(self.openfl, 3, 1, 1, 1)

        self.start = QtWidgets.QPushButton(self.layoutWidget)
        self.start.clicked.connect(self.click_detection)
        self.start.setObjectName("start")
        self.gridLayout_2.addWidget(self.start, 4, 0, 1, 1)

        self.data_t = QtWidgets.QLabel(self.layoutWidget)
        self.data_t.setObjectName("data_t")
        self.gridLayout_2.addWidget(self.data_t, 5, 0, 1, 1)

        self.testdata = QtWidgets.QComboBox(self.layoutWidget)
        self.testdata .addItem("PCBTEST.json")
        self.testdata .addItem("LEDTEST.json")
        self.testdata.setObjectName("testdata")
        self.gridLayout_2.addWidget(self.testdata, 6, 0, 1, 2)

        self.test = QtWidgets.QPushButton(self.layoutWidget)
        self.test.clicked.connect(self.test_json)
        self.test.setObjectName("test")
        self.gridLayout_2.addWidget(self.test, 7, 0, 1, 1)
        self.iou = QtWidgets.QLabel(self.layoutWidget)
        self.iou.setObjectName("iou")
        self.gridLayout_2.addWidget(self.iou, 8, 0, 1, 1)
        
        self.horizontalSlider = QtWidgets.QSlider(self.centralwidget)
        self.horizontalSlider.setGeometry(QtCore.QRect(20, 370, 181, 21))
        self.horizontalSlider.setOrientation(QtCore.Qt.Horizontal)
        #  # 括号里为对应槽函数名20, 400, 181, 21
        self.horizontalSlider.setMinimum(0)
        self.horizontalSlider.setMaximum(100)
        self.horizontalSlider.setValue(80)
        self.horizontalSlider.setTickInterval(1)
        self.horizontalSlider.setObjectName("horizontalSlider")
        self.horizontalSlider.valueChanged.connect(lambda: self.splider_change())  # 滑块的connect
        self.ioubox = QtWidgets.QDoubleSpinBox(self.centralwidget)
        self.ioubox.setGeometry(QtCore.QRect(20, 320, 221, 28))
        self.ioubox.setMinimum(0)
        self.ioubox.setMaximum(1)
        self.ioubox.setValue(0.8)
        self.ioubox.valueChanged.connect(lambda: self.ioubox_change())
        self.ioubox.setObjectName("ioubox")
        self.value1 = self.ioubox.value() * 100
        self.value = self.horizontalSlider.value() * 0.01

        self.widget2 = QtWidgets.QWidget(self.centralwidget)
        self.widget2.setGeometry(QtCore.QRect(20, 400, 221, 100))
        self.widget2.setObjectName("widget2")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.widget2)
        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.numclass = QtWidgets.QLabel(self.widget2)
        self.numclass.setScaledContents(False)
        self.numclass.setWordWrap(False)
        self.numclass.setObjectName("numclass")
        self.gridLayout_4.addWidget(self.numclass, 0, 0, 1, 1)
        self.classbox = QtWidgets.QSpinBox(self.widget2)
        self.classbox.setObjectName("classbox")
        self.gridLayout_4.addWidget(self.classbox, 1, 0, 1, 1)
        self.result = QtWidgets.QLabel(self.widget2)
        self.result.setObjectName("result")
        self.gridLayout_4.addWidget(self.result, 2, 0, 1, 1)

        self.layoutWidget1 = QtWidgets.QWidget(self.centralwidget)
        self.layoutWidget1.setGeometry(QtCore.QRect(258, 10, 700, 21))
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.layoutWidget1)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.origin = QtWidgets.QLabel(self.layoutWidget1)
        self.origin.setFrameShape(QtWidgets.QFrame.Panel)
        self.origin.setFrameShadow(QtWidgets.QFrame.Raised)
        self.origin.setLineWidth(2)
        self.origin.setObjectName("origin")
        self.horizontalLayout_2.addWidget(self.origin)
        self.last = QtWidgets.QLabel(self.layoutWidget1)
        self.last.setFrameShape(QtWidgets.QFrame.Panel)
        self.last.setFrameShadow(QtWidgets.QFrame.Raised)
        self.last.setLineWidth(2)
        self.last.setObjectName("last")
        self.horizontalLayout_2.addWidget(self.last)
        self.path = QtWidgets.QLabel(self.layoutWidget1)
        self.path.setObjectName("path")
        self.horizontalLayout_2.addWidget(self.path)

        self.layoutWidget2 = QtWidgets.QWidget(self.centralwidget)
        self.layoutWidget2.setGeometry(QtCore.QRect(20, 500, 1182, 200))
        self.layoutWidget2.setObjectName("layoutWidget2")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.layoutWidget2)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.resultext = QtWidgets.QTextBrowser(self.layoutWidget2)
        self.resultext.setObjectName("resultext")
        self.horizontalLayout.addWidget(self.resultext)
        self.resultclass = QtWidgets.QTextBrowser(self.layoutWidget2)
        self.resultclass.setObjectName("resultclass")
        self.horizontalLayout.addWidget(self.resultclass)

        self.layoutWidget3 = QtWidgets.QWidget(self.centralwidget)
        self.layoutWidget3.setGeometry(QtCore.QRect(250, 40, 965, 454))
        self.layoutWidget3.setObjectName("layoutWidget3")
        self.gridLayout = QtWidgets.QGridLayout(self.layoutWidget3)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")
        self.picture1 = QtWidgets.QLabel(self.layoutWidget3)
        self.picture1.setFrameShape(QtWidgets.QFrame.Panel)
        self.picture1.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.picture1.setLineWidth(1)
        self.picture1.setMidLineWidth(1)
        self.picture1.setText("")
        self.picture1.setScaledContents(True)
        self.picture1.setMaximumSize(227,227)
        self.picture1.setMinimumSize(227,100)
        self.picture1.setObjectName("picture1")
        self.gridLayout.addWidget(self.picture1, 0, 0, 1, 1)

        self.res18 = QtWidgets.QLabel(self.layoutWidget3)
        self.res18.setFrameShape(QtWidgets.QFrame.Panel)
        self.res18.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.res18.setLineWidth(1)
        self.res18.setMidLineWidth(1)
        self.res18.setText("")
        self.res18.setScaledContents(True)
        self.res18.setMaximumSize(227,227)
        self.res18.setMinimumSize(227,100)
        self.res18.setObjectName("res18")
        self.gridLayout.addWidget(self.res18, 0, 1, 1, 1)

        self.res50 = QtWidgets.QLabel(self.layoutWidget3)
        self.res50.setFrameShape(QtWidgets.QFrame.Panel)
        self.res50.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.res50.setLineWidth(1)
        self.res50.setMidLineWidth(1)
        self.res50.setText("")
        self.res50.setScaledContents(True)
        self.res50.setMaximumSize(227 ,227)
        self.res50.setMinimumSize(227,100)
        self.res50.setObjectName("res50")
        self.gridLayout.addWidget(self.res50, 0, 2, 1, 1)

        self.res101 = QtWidgets.QLabel(self.layoutWidget3)
        self.res101.setFrameShape(QtWidgets.QFrame.Panel)
        self.res101.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.res101.setLineWidth(1)
        self.res101.setMidLineWidth(1)
        self.res101.setText("")
        self.res101.setMaximumSize(227,227)
        self.res101.setMinimumSize(227,100)
        self.res101.setScaledContents(True)
        self.res101.setObjectName("res101")
        self.gridLayout.addWidget(self.res101, 0, 3, 1, 1)

        self.res101_50 = QtWidgets.QLabel(self.layoutWidget3)
        self.res101_50.setFrameShape(QtWidgets.QFrame.Panel)
        self.res101_50.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.res101_50.setLineWidth(1)
        self.res101_50.setMidLineWidth(1)
        self.res101_50.setText("")
        self.res101_50.setMaximumSize(227,227)
        self.res101_50.setMinimumSize(227,100)
        self.res101_50.setScaledContents(True)
        self.res101_50.setObjectName("res101_50")
        self.gridLayout.addWidget(self.res101_50, 1, 3, 1, 1)

        self.res101_18 = QtWidgets.QLabel(self.layoutWidget3)
        self.res101_18.setFrameShape(QtWidgets.QFrame.Panel)
        self.res101_18.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.res101_18.setLineWidth(1)
        self.res101_18.setMidLineWidth(1)
        self.res101_18.setText("")
        self.res101_18.setMaximumSize(227,227)
        self.res101_18.setMinimumSize(227,100)
        self.res101_18.setScaledContents(True)
        self.res101_18.setObjectName("res101_18")
        self.gridLayout.addWidget(self.res101_18, 1, 2, 1, 1)

        self.label = QtWidgets.QLabel(self.layoutWidget3)
        self.label.setFrameShape(QtWidgets.QFrame.Panel)
        #self.label.setFrameShadow(QtWidgets.QFrame.Raised)
        self.label.setLineWidth(1)
        self.label.setMaximumSize(227,227)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 1, 1, 1, 1)

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1234, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def splider_change(self):
        value = self.horizontalSlider.value()*0.01
        self.ioubox.setValue(value)

    def ioubox_change(self):
        value1 = self.ioubox.value()*100
        self.horizontalSlider.setValue(value1)
        print(value1)

    def printf(self, mes):
        self.resultext.append(str(mes))  # 在指定的区域显示提示信息
        self.cursot = self.resultext.textCursor()
        self.resultext.moveCursor(self.cursot.End)
        QtWidgets.QApplication.processEvents()

    def open_pth(self):
        filePath, filetype = QtWidgets.QFileDialog.getOpenFileName()
        print(filePath)
        self.pth.setText(filePath)

    def open_file(self):
        filePath, filetype = QtWidgets.QFileDialog.getOpenFileName()
        print(filePath)
        pix1 = QPixmap(filePath)
        self.path.setText(filePath)
        self.picture1.setPixmap(pix1)

    def open_floder(self):
        dir_path = QtWidgets.QFileDialog.getExistingDirectory()
        print(dir_path)
        self.flpath.setText(dir_path)

    def click_detection(self):
        s = self.comboBox.currentText()
        self.resultext.append(s)
        save_folder = '/home/ps/DiskA/project/GZY1'
        if s == '支持的五种模型缺陷检测的对比':
            cfg = get_cfg()
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res18/config/Retinanet-18-small.yaml'
            weight = '/home/ps/DiskA/project/GZY1/result/18/small/model_final.pth'
            value1 = self.ioubox.value()  
            img_file = self.path.text() 
            cfg.merge_from_file(yaml)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	   #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果   
            pix18 = QPixmap(save_result_path)
            self.res18.setPixmap(pix18)
            cfg = get_cfg()
            value1 = self.ioubox.value()  
            img_file = self.path.text() 
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res50/config/RetinaNet-50-small.yaml'
            weight = '/home/ps/DiskA/project/GZY1/result/50/small/model_final.pth'
            cfg.merge_from_file(yaml)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	   #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果  
            pix50 = QPixmap(save_result_path)
            self.res50.setPixmap(pix50)
            cfg = get_cfg()
            value1 = self.ioubox.value()  
            img_file = self.path.text() 
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res101/config/RetinaNet_101-small.yaml'
            weight = '/home/ps/DiskA/project/GZY1/result/101/small/model_final.pth'
            cfg.merge_from_file(yaml)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	   #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果  
            pix101 = QPixmap(save_result_path)
            self.res101.setPixmap(pix101) 
            cfg = get_cfg()
            value1 = self.ioubox.value()  
            img_file = self.path.text() 
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/DistillT_Res101_S_Res50_small.yaml'
            weight = '/home/ps/DiskA/project/GZY1/result/101-50/small/model_final.pth'
            cfg = add_distill_cfg(cfg)
            cfg.merge_from_file(yaml)
            cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
            cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	       #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果
            pixd50 = QPixmap(save_result_path)
            self.res101_50.setPixmap(pixd50) 
            cfg = get_cfg()
            value1 = self.ioubox.value()  
            img_file = self.path.text() 
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/Distill_T_res101_S_res18-small.yaml'
            weight = '/home/ps/DiskA/project/GZY1/result/101-18/small/model_final.pth'
            cfg = add_distill_cfg(cfg)
            cfg.merge_from_file(yaml)
            cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
            cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	       #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果
            pixd18 = QPixmap(save_result_path)
            self.res101_18.setPixmap(pixd18) 
        elif s == 'res18-fpn-retinanet':
            cfg = get_cfg()
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res18/config/Retinanet-18-small.yaml'
            weight = self.pth.text() 
            value1 = self.ioubox.value()  
            img_file = self.path.text() 
            cfg.merge_from_file(yaml)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	   #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果   
            pix = QPixmap(save_result_path)
            self.res18.setPixmap(pix)
        elif s == 'res50-fpn-retinanet':
            cfg = get_cfg()
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res18/config/Retinanet-18-small.yaml'
            weight = self.pth.text() 
            value1 = self.ioubox.value()  
            img_file = self.path.text() 
            cfg.merge_from_file(yaml)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	   #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果  
            pix = QPixmap(save_result_path)
            self.res50.setPixmap(pix)
        elif s == 'res101-fpn-retinanet':
            cfg = get_cfg()
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res18/config/Retinanet-18-small.yaml'
            weight = self.pth.text() 
            value1 = self.ioubox.value()  
            img_file = self.path.text() 
            cfg.merge_from_file(yaml)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	   #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果   
            pix = QPixmap(save_result_path)
            self.res101.setPixmap(pix)
        elif s == 'res101-50-fpn-retinanet':
            cfg = get_cfg()
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/DistillT_Res101_S_Res50_small.yaml'
            weight = self.pth.text() 
            cfg = add_distill_cfg(cfg)
            cfg.merge_from_file(yaml)
            cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
            cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	       #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果
            pix = QPixmap(save_result_path)
            self.res101_50.setPixmap(pix)
        else:
            cfg = get_cfg()
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/Distill_T_res101_S_res18-small.yaml'
            weight = self.pth.text() 
            cfg = add_distill_cfg(cfg)
            cfg.merge_from_file(yaml)
            cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
            cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
            congif = '所选的配置文件为：' + yaml
            self.resultclass.append(congif)
            self.resultext.append(congif)
            nclasses = self.numclass.text()
            classes = self.classbox.value() #缺陷检测种类数
            cls = self.classbox.text()
            num = nclasses + ':' + cls
            self.resultext.append(num)
            cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR,weight)
            model = build_model(cfg)
            ui.printf(model)
            im = cv2.imread(img_file)
            img_file = os.path.basename(img_file)
            save_result_path = os.path.join(save_folder, img_file)
            height = im.shape[0]
            width = im.shape[1]
            dpi = 500
            predictor = DefaultPredictor(cfg)
            outsputs = predictor(im)
            pred_classes = outsputs["instances"].pred_classes
            pred_boxes = outsputs["instances"].scores
            acc =torch.stack([pred_classes,pred_boxes],dim=1)
            out = list(filter(lambda x:x[1]>value1, acc))
            self.resultclass.append(str(out))
	       #在原图上画出检测结果
            v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
            v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
            plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
            plt.axis('off')
            plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
            plt.imshow(v.get_image())
            plt.savefig(save_result_path) #保存结果
            pix = QPixmap(save_result_path)
            self.res101_18.setPixmap(pix)  

    def click_floder(self):
        save_folder = '/home/ps/DiskA/project/GZY1/OUTPUT'
        cfg = get_cfg()
        im_folder = self.flpath.text() 
        value1 = self.ioubox.value()   #iou
        weight = self.pth.text()    #.pth   
        s = self.comboBox.currentText()
        nclasses = self.numclass.text()
        classes = self.classbox.value() #缺陷检测种类数
        cls = self.classbox.text()
        num = nclasses + ':' + cls
        self.resultext.append(num)
        self.resultext.append(s)    
        if s == 'res18-fpn-retinanet':
           yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res18/config/Retinanet-18-small.yaml'
           cfg.merge_from_file(yaml)
           cfg.MODEL.RETINANET.NUM_CLASSES = classes
           congif = '所选的配置文件为：' + yaml
           self.resultext.append(congif)
           for im_file in os.listdir(im_folder):
               print(im_file)
               im_fl = im_folder + '/' + im_file
               print(im_fl)
               pix1 = QPixmap(im_fl)
               self.picture1.setPixmap(pix1)
               im = cv2.imread(os.path.join(im_folder,im_file))
               save_result_path = os.path.join(save_folder, im_file)
               height = im.shape[0]
               width = im.shape[1]
               dpi = 500
               cfg.MODEL.ROI_HEADS.NMS_THRESH_TEST = 0.4
               cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5  #模型阈值
               cfg.MODEL.ROI_HEADS.PROPOSAL_APPEND_GT = True
               cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight) 
               model = build_model(cfg)
               print(model)
               predictor = DefaultPredictor(cfg) 
               outsputs = predictor(im)
               pred_classes = outsputs["instances"].pred_classes
               pred_boxes = outsputs["instances"].scores
               acc =torch.stack([pred_classes,pred_boxes],dim=1)
               out = list(filter(lambda x:x[1]>value1, acc))
               self.resultclass.append(str(out))
               #在原图上画出检测结果
               v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
               v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
               plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
               plt.axis('off')
               plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
               plt.imshow(v.get_image())
               plt.savefig(save_result_path) #保存结果
               pix2 = QPixmap(save_result_path)
               self.res18.setPixmap(pix2)
               self.resultclass.append(save_result_path)
        elif s == 'res50-fpn-retinanet':
           yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res50/config/RetinaNet-50-small.yaml'
           cfg.merge_from_file(yaml)
           cfg.MODEL.RETINANET.NUM_CLASSES = classes
           congif = '所选的配置文件为：' + yaml
           self.resultext.append(congif)
           for im_file in os.listdir(im_folder):
               print(im_file)
               im_fl = im_folder + '/' + im_file
               print(im_fl)
               pix1 = QPixmap(im_fl)
               self.picture1.setPixmap(pix1)
               im = cv2.imread(os.path.join(im_folder,im_file))
               save_result_path = os.path.join(save_folder, im_file)
               height = im.shape[0]
               width = im.shape[1]
               dpi = 500
               cfg.MODEL.ROI_HEADS.NMS_THRESH_TEST = 0.4
               cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5  #模型阈值
               cfg.MODEL.ROI_HEADS.PROPOSAL_APPEND_GT = True
               cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight) 
               model = build_model(cfg)
               print(model)
               predictor = DefaultPredictor(cfg) 
               outsputs = predictor(im)
               pred_classes = outsputs["instances"].pred_classes
               pred_boxes = outsputs["instances"].scores
               acc =torch.stack([pred_classes,pred_boxes],dim=1)
               out = list(filter(lambda x:x[1]>value1, acc))
               self.resultclass.append(str(out))
               #在原图上画出检测结果
               v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
               v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
               plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
               plt.axis('off')
               plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
               plt.imshow(v.get_image())
               plt.savefig(save_result_path) #保存结果
               pix2 = QPixmap(save_result_path)
               self.res50.setPixmap(pix2)
               self.resultclass.append(save_result_path)
        elif s == 'res101-fpn-retinanet':
           yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res101/config/RetinaNet_101-small.yaml'
           cfg.merge_from_file(yaml)
           cfg.MODEL.RETINANET.NUM_CLASSES = classes
           congif = '所选的配置文件为：' + yaml
           self.resultext.append(congif)
           for im_file in os.listdir(im_folder):
               print(im_file)
               im_fl = im_folder + '/' + im_file
               print(im_fl)
               pix1 = QPixmap(im_fl)
               self.picture1.setPixmap(pix1)
               im = cv2.imread(os.path.join(im_folder,im_file))
               save_result_path = os.path.join(save_folder, im_file)
               height = im.shape[0]
               width = im.shape[1]
               dpi = 500
               cfg.MODEL.ROI_HEADS.NMS_THRESH_TEST = 0.4
               cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5  #模型阈值
               cfg.MODEL.ROI_HEADS.PROPOSAL_APPEND_GT = True
               cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight) 
               model = build_model(cfg)
               print(model)
               predictor = DefaultPredictor(cfg) 
               outsputs = predictor(im)
               pred_classes = outsputs["instances"].pred_classes
               pred_boxes = outsputs["instances"].scores
               acc =torch.stack([pred_classes,pred_boxes],dim=1)
               out = list(filter(lambda x:x[1]>value1, acc))
               self.resultclass.append(str(out))
               #在原图上画出检测结果
               v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
               v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
               plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
               plt.axis('off')
               plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
               plt.imshow(v.get_image())
               plt.savefig(save_result_path) #保存结果
               pix2 = QPixmap(save_result_path)
               self.res101.setPixmap(pix2)
               self.resultclass.append(save_result_path)
        elif s == 'res101-50-fpn-retinanet':
           cfg = add_distill_cfg(cfg)          
           yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/DistillT_Res101_S_Res50_small.yaml'
           cfg.merge_from_file(yaml)
           cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
           cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
           cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
           cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
           congif = '所选的配置文件为：' + yaml
           self.resultext.append(congif)
           for im_file in os.listdir(im_folder):
               print(im_file)
               im_fl = im_folder + '/' + im_file
               print(im_fl)
               pix1 = QPixmap(im_fl)
               self.picture1.setPixmap(pix1)
               im = cv2.imread(os.path.join(im_folder,im_file))
               save_result_path = os.path.join(save_folder, im_file)
               height = im.shape[0]
               width = im.shape[1]
               dpi = 500
               cfg.MODEL.ROI_HEADS.NMS_THRESH_TEST = 0.4
               cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5  #模型阈值
               cfg.MODEL.ROI_HEADS.PROPOSAL_APPEND_GT = True
               cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight) 
               model = build_model(cfg)
               print(model)
               predictor = DefaultPredictor(cfg) 
               outsputs = predictor(im)
               pred_classes = outsputs["instances"].pred_classes
               pred_boxes = outsputs["instances"].scores
               acc =torch.stack([pred_classes,pred_boxes],dim=1)
               out = list(filter(lambda x:x[1]>value1, acc))
               self.resultclass.append(str(out))
               #在原图上画出检测结果
               v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
               v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
               plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
               plt.axis('off')
               plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
               plt.imshow(v.get_image())
               plt.savefig(save_result_path) #保存结果
               pix2 = QPixmap(save_result_path)
               self.res101_50.setPixmap(pix2)
               self.resultclass.append(save_result_path)
        else :
            cfg = add_distill_cfg(cfg)  
            yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/Distill_T_res101_S_res18-small.yaml'
            cfg.merge_from_file(yaml)
            cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
            cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
            cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
            congif = '所选的配置文件为：' + yaml
            self.resultext.append(congif)
            for im_file in os.listdir(im_folder):
               print(im_file)
               im_fl = im_folder + '/' + im_file
               print(im_fl)
               pix1 = QPixmap(im_fl)
               self.picture1.setPixmap(pix1)
               im = cv2.imread(os.path.join(im_folder,im_file))
               save_result_path = os.path.join(save_folder, im_file)
               height = im.shape[0]
               width = im.shape[1]
               dpi = 500
               cfg.MODEL.ROI_HEADS.NMS_THRESH_TEST = 0.4
               cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5  #模型阈值
               cfg.MODEL.ROI_HEADS.PROPOSAL_APPEND_GT = True
               cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight) 
               model = build_model(cfg)
               print(model)
               predictor = DefaultPredictor(cfg) 
               outsputs = predictor(im)
               pred_classes = outsputs["instances"].pred_classes
               pred_boxes = outsputs["instances"].scores
               acc =torch.stack([pred_classes,pred_boxes],dim=1)
               out = list(filter(lambda x:x[1]>value1, acc))
               self.resultclass.append(str(out))
               #在原图上画出检测结果
               v = Visualizer(im[:, :, ::-1], MetadataCatalog.get(cfg.DATASETS.TRAIN[0]), scale=0.5,instance_mode=ColorMode.IMAGE_BW)
               v = v.draw_instance_predictions(outsputs["instances"].to("cpu"),value1)
               plt.figure(figsize=(width/dpi, height/dpi), dpi=dpi)
               plt.axis('off')
               plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0, hspace = 0, wspace = 0)
               plt.imshow(v.get_image())
               plt.savefig(save_result_path) #保存结果
               pix2 = QPixmap(save_result_path)
               self.res101_18.setPixmap(pix2)
               self.resultclass.append(save_result_path)
        self.resultext.append('批量缺陷检测结果保存在以下文件夹：')
        self.resultext.append(os.path.dirname(save_result_path)) 

    def test_json(self):
        s1 = self.testdata.currentText()      
        weight = self.pth.text()    #.pth
        s = self.comboBox.currentText()
        nclasses = self.numclass.text()
        classes = self.classbox.value() #缺陷检测种类数
        cls = self.classbox.text()
        num = nclasses + ':' + cls
        self.resultext.append(num)
        self.resultext.append(s)
        if s == 'res18-fpn-retinanet':
            if s1 == 'PCBTEST.json':
                cfg = get_cfg()
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res18/config/Retinanet-18-small.yaml'
                cfg.merge_from_file(yaml)
                cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("val",)
                cfg.DATASETS.TRAIN = ("train",)
                cfg.MODEL.WEIGHTS = weight
                trainer = DefaultTrainer(cfg)
                trainer.resume_or_load(resume=True)
                DetectionCheckpointer(trainer.model, save_dir="/home/ps/DiskA/project/GZY1/result/18/PCB").resume_or_load(cfg.MODEL.WEIGHTS, resume=True)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/18/PCB")
                val_loader = build_detection_test_loader(cfg, "val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res18-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
            elif s1 =='LEDTEST.json':
                cfg = get_cfg()
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res18/config/Retinanet-18-small.yaml'
                cfg.merge_from_file(yaml)
                cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("coco_val",)
                cfg.DATASETS.TRAIN = ("coco_train",)
                cfg.MODEL.WEIGHTS = weight
                trainer = DefaultTrainer(cfg)
                trainer.resume_or_load(resume=True)
                DetectionCheckpointer(trainer.model, save_dir="/home/ps/DiskA/project/GZY1/result/18/small").resume_or_load(cfg.MODEL.WEIGHTS, resume=True)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("coco_val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/18/small")
                val_loader = build_detection_test_loader(cfg, "coco_val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res18-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
        elif s == 'res50-fpn-retinanet':
            if s1 == 'PCBTEST.json':
                cfg = get_cfg()
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res50/config/RetinaNet-50-PCB.yaml'
                cfg.merge_from_file(yaml)
                cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("val",)
                cfg.DATASETS.TRAIN = ("train",)
                cfg.MODEL.WEIGHTS = weight
                trainer = DefaultTrainer(cfg)
                trainer.resume_or_load(resume=True)
                DetectionCheckpointer(trainer.model, save_dir="/home/ps/DiskA/project/GZY1/result/18/PCB").resume_or_load(cfg.MODEL.WEIGHTS, resume=True)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/18/PCB")
                val_loader = build_detection_test_loader(cfg, "val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res50-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
            elif s1 =='LEDTEST.json':
                cfg = get_cfg()
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res50/config/RetinaNet-50-small.yaml'
                cfg.merge_from_file(yaml)
                cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("coco_val",)
                cfg.DATASETS.TRAIN = ("coco_train",)
                cfg.MODEL.WEIGHTS = weight
                trainer = DefaultTrainer(cfg)
                trainer.resume_or_load(resume=True)
                DetectionCheckpointer(trainer.model, save_dir="/home/ps/DiskA/project/GZY1/result/50/small").resume_or_load(cfg.MODEL.WEIGHTS, resume=True)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("coco_val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/50/small")
                val_loader = build_detection_test_loader(cfg, "coco_val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res50-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
        elif s == 'res101-fpn-retinanet':
            if s1 == 'PCBTEST.json':
                cfg = get_cfg()
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res101/config/RetinaNet_101-small.yaml'
                cfg.merge_from_file(yaml)
                cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("val",)
                cfg.DATASETS.TRAIN = ("train",)
                cfg.MODEL.WEIGHTS = weight
                trainer = DefaultTrainer(cfg)
                trainer.resume_or_load(resume=True)
                DetectionCheckpointer(trainer.model, save_dir="/home/ps/DiskA/project/GZY1/result/18/PCB").resume_or_load(cfg.MODEL.WEIGHTS, resume=True)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/18/PCB")
                val_loader = build_detection_test_loader(cfg, "val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res101-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
            elif s1 =='LEDTEST.json':
                cfg = get_cfg()
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/RetinaNet_Res101/config/RetinaNet_101-small.yaml'
                cfg.merge_from_file(yaml)
                cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("coco_val",)
                cfg.DATASETS.TRAIN = ("coco_train",)
                cfg.MODEL.WEIGHTS = weight
                trainer = DefaultTrainer(cfg)
                trainer.resume_or_load(resume=True)
                DetectionCheckpointer(trainer.model, save_dir="/home/ps/DiskA/project/GZY1/result/101/small").resume_or_load(cfg.MODEL.WEIGHTS, resume=True)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("coco_val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/101/small")
                val_loader = build_detection_test_loader(cfg, "coco_val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res101-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
        elif s == 'res101-50-fpn-retinanet':
            if s1 == 'PCBTEST.json':
                cfg = get_cfg()
                cfg = add_distill_cfg(cfg)          
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/DistillT_Res101_S_Res50_small.yaml'
                cfg.merge_from_file(yaml)
                cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
                cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
                cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
                cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
          #     cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("val",)
                cfg.DATASETS.TRAIN = ("train",)
                cfg.DISTILL.STUDENT_CFG.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight)
                trainer = DefaultTrainerDistill(cfg)
                trainer.resume_or_load(resume=True)
                DetectionCheckpointer(trainer.model, save_dir="/home/ps/DiskA/project/GZY1/result/101-50/PCB").resume_or_load(cfg.MODEL.WEIGHTS, resume=True)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/101-50/PCB")
                val_loader = build_detection_test_loader(cfg, "val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res101-50-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
            elif s1 =='LEDTEST.json':
                cfg = get_cfg()
                cfg = add_distill_cfg(cfg)          
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/DistillT_Res101_S_Res50_small.yaml'
                cfg.merge_from_file(yaml)
                cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
                cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
                cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
                cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
          #     cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("coco_val",)
                cfg.DATASETS.TRAIN = ("coco_train",)
                cfg.DISTILL.STUDENT_CFG.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight)
                trainer = DefaultTrainerDistill(cfg)
                trainer.resume_or_load(resume=True)
                DetectionCheckpointer(trainer.model, save_dir="/home/ps/DiskA/project/GZY1/result/101-50/small").resume_or_load(cfg.MODEL.WEIGHTS, resume=True)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("coco_val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/101-50/small")
                val_loader = build_detection_test_loader(cfg, "coco_val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res101-50-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
        else :
            if s1 == 'PCBTEST.json':
                cfg = get_cfg()
                cfg = add_distill_cfg(cfg)          
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/Distill_T_res101_S_res18-small.yaml'
                cfg.merge_from_file(yaml)
                cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
                cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
                cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
                cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
          #     cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("val",)
                cfg.DATASETS.TRAIN = ("train",)
                cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight)
                trainer = DefaultTrainerDistill(cfg)
                trainer.resume_or_load(resume=True)  # resume=True means load a file cfg.OUTPUT_DIR
                DetectionCheckpointer(trainer.model).load(cfg.MODEL.WEIGHTS)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/101-18/PCB")
                val_loader = build_detection_test_loader(cfg, "val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res101-18-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))
            elif s1 =='LEDTEST.json':
                cfg = get_cfg()
                cfg = add_distill_cfg(cfg)          
                yaml = '/home/ps/DiskA/project/GZY1/Distill_GID_detectron2/GID/config/Distill_T_res101_S_res18-small.yaml'
                cfg.merge_from_file(yaml)
                cfg.DISTILL.TEACHER_CFG.merge_from_file(cfg.DISTILL.TEACHER_YAML)
                cfg.DISTILL.STUDENT_CFG.merge_from_file(cfg.DISTILL.STUDENT_YAML)
                cfg.DISTILL.TEACHER_CFG.MODEL.RETINANET.NUM_CLASSES = classes
                cfg.DISTILL.STUDENT_CFG.MODEL.RETINANET.NUM_CLASSES = classes
          #     cfg.MODEL.RETINANET.NUM_CLASSES = classes
                congif = '所选的配置文件为：' + yaml
                self.resultext.append(congif)
                cfg.DATASETS.TEST = ("coco_val",)
                cfg.DATASETS.TRAIN = ("coco_train",)
                cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, weight)
                trainer = DefaultTrainerDistill(cfg)
                trainer.resume_or_load(resume=True)  # resume=True means load a file cfg.OUTPUT_DIR
                DetectionCheckpointer(trainer.model).load(cfg.MODEL.WEIGHTS)
                predictor = DefaultPredictor(cfg)
                evaluator = COCOEvaluator("coco_val", cfg, False, output_dir="/home/ps/DiskA/project/GZY1/result/101-18/small")
                val_loader = build_detection_test_loader(cfg, "coco_val")
                result1 = inference_on_dataset(trainer.model, val_loader, evaluator)
                ui.printf(trainer.model)
                self.resultclass.append('res101-18-fpn-retinanet模型的评估结果为：')
                self.resultclass.append(str(result1))

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.cmodel.setText(_translate("MainWindow", "选择模型结构"))
        self.openpic.setText(_translate("MainWindow", "打开图片"))
        self.openfloder.setText(_translate("MainWindow", "打开文件夹"))
        self.openpkl.setText(_translate("MainWindow", "选择权重文件"))
        self.openfl.setText(_translate("MainWindow", "批量缺陷检测"))
        self.start.setText(_translate("MainWindow", "开始检测"))
        self.data_t.setText(_translate("MainWindow", "选择测试数据集"))
        self.test.setText(_translate("MainWindow", "开始测试"))
        self.iou.setText(_translate("MainWindow", "置信度"))
        self.numclass.setText(_translate("MainWindow", "缺陷种类数（num_class)"))
        self.result.setText(_translate("MainWindow", "检测结果/评估日志"))
        self.origin.setText(_translate("MainWindow", "原始图片"))
        self.last.setText(_translate("MainWindow", "缺陷检测后的图片"))
        self.label.setText(_translate("MainWindow", "\n右图:\n蒸馏过的retinanet的检测结果\n""1.res101-18_fpn_retinanet\n""2.res101-50_fpn_retinanet\n""上图:\n未蒸馏的retinanet的检测结果\n""1.res18-fpn-retinanet\n""2.res50-fpn-retinanet\n""3.res101-fpn-retinanet\n""\n""\n""\n""\n"""))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())